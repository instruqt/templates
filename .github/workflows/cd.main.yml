name: CD
on:
  pull_request:
    branches:
      - main
# env:
# ENV: Production
# INSTRUQT_TOKEN: ${{ secrets.INSTRUQT_TOKEN }}
# TRACKS_WORKDIR: /
jobs:
  scope:
    runs-on: ubuntu-latest
    steps:
      - name: Finds scope
        uses: jitterbit/get-changed-files@v1
  # Goal: Find tracks that have been changed and push changes
  # Get scope with modified files, filter to unique trackSlug
  # cd to $TRACK_WORKDIR/trackSlug for all unique edited tracks
  # run `instruqt track push`
  push-tracks:
    needs: scope
    runs-on: ubuntu-latest
    steps:
      - name: Finding modified tracks
        run: |
          # Read list of modified files from jobs.scope.outputs
          # create slugs array
          slugs=()
          # Loop over modified files
            for modified_file_path in ${{ steps.files.outputs.all }}; do
            # Split modified_file_path on '/' as split_path
            IFS='/' read -ra split_path <<< modified_file_path
            # Add first index to slugs list, which _should_ be the slug
            slugs+=(split_path[0])
          done
          # filter unique slugs as unique_slugs
          unique_slugs=($(echo "${slugs[@]}" | tr ' ' '\n' | sort -u | tr '\n' ' '))
          # set $UNIQUE_MODIFIED_TRACKS env var so we can use it in the next step
          echo "UNIQUE_MODIFIED_TRACKS=$slugs" >> $GITHUB_ENV

      - name: Pushing updated and/or new tracks
        run: |
          echo "${{ env.UNIQUE_MODIFIED_TRACKS }}"
  # Goal: Find tracks that have been deleted entirely
  # Get scope with deleted files.
  # Check whether the track folder still eixsts
  # If yes, it's not entirely deleted, dont do anything
  # If no, the whole track has been deleted, run `instruqt track delete orgSlug/trackSlug`
  delete-tracks:
    needs: scope
    runs-on: ubuntu-latest
    steps:
      - name: Deleting removed tracks
        run: |
          echo "We ran the thing!"
